// stda_cli.c - Complete with Mulligan and Discard-to-7

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef _WIN32
  #include <windows.h>
#endif

#include "stda_cli.h"
#include "game_types.h"
#include "mtwister.h"
#include "game_constants.h"
#include "strategy.h"
#include "strat_random.h"
#include "game_state.h"
#include "turn_logic.h"
#include "combat.h"
#include "card_actions.h"
#include "stda_auto.h"

#define MAX_COMMAND_LEN 256
#define EXIT_SIGNAL -1
#define ACTION_TAKEN 1
#define NO_ACTION 0

// ANSI color codes
#define RESET   "\033[0m"
#define RED     "\033[31m"
#define GREEN   "\033[32m"
#define YELLOW  "\033[33m"
#define BLUE    "\033[34m"
#define MAGENTA "\033[35m"
#define CYAN    "\033[36m"
#define BOLD_WHITE   "\033[1;37m"
#define COLOR_P1      "\033[1;36m"
#define COLOR_P2      "\033[1;33m"
#define COLOR_ENERGY  MAGENTA
#define COLOR_LUNA    CYAN

/* ========================================================================
   Helper Functions (Shared by Mulligan and Discard)
   ======================================================================== */

void display_card_with_index(uint8_t card_idx, int display_num, int show_power)
{ const struct card* c = &fullDeck[card_idx];
  
  if(c->card_type == CHAMPION_CARD)
  { const char* color = (c->color == COLOR_INDIGO) ? BLUE :
                        (c->color == COLOR_ORANGE) ? YELLOW : RED;
    if(show_power)
      printf("  [%d] %s%s" RESET " (D%d+%d, " CYAN "â˜¾%d" RESET ", pwr:%.1f)\n",
             display_num, color, CHAMPION_SPECIES_NAMES[c->species],
             c->defense_dice, c->attack_base, c->cost, c->power);
    else
      printf("  [%d] %s%s" RESET " (D%d+%d, " CYAN "â˜¾%d" RESET ")\n",
             display_num, color, CHAMPION_SPECIES_NAMES[c->species],
             c->defense_dice, c->attack_base, c->cost);
  }
  else if(c->card_type == DRAW_CARD)
  { if(show_power)
      printf("  [%d] " YELLOW "Draw %d" RESET " (" CYAN "â˜¾%d" RESET ", pwr:%.1f)\n",
             display_num, c->draw_num, c->cost, c->power);
    else
      printf("  [%d] " YELLOW "Draw %d" RESET " (" CYAN "â˜¾%d" RESET ")\n",
             display_num, c->draw_num, c->cost);
  }
  else if(c->card_type == CASH_CARD)
  { if(show_power)
      printf("  [%d] " GREEN "Exchange for %d lunas" RESET " (" CYAN "â˜¾%d" RESET ", pwr:%.1f)\n",
             display_num, c->exchange_cash, c->cost, c->power);
    else
      printf("  [%d] " GREEN "Exchange for %d lunas" RESET " (" CYAN "â˜¾%d" RESET ")\n",
             display_num, c->exchange_cash, c->cost);
  }
}

int parse_card_indices_cli(char* input, uint8_t* indices, int max_count, int hand_size)
{ int count = 0;
  char* token = strtok(input, " ");
  
  while(token != NULL && count < max_count)
  { int idx = atoi(token);
    if(idx < 1 || idx > hand_size)
    { printf(RED "Error: Invalid card number %d (must be 1-%d)\n" RESET, idx, hand_size);
      return -1;
    }
    
    for(int i = 0; i < count; i++)
    { if(indices[i] == (idx - 1))
      { printf(RED "Error: Duplicate card number %d\n" RESET, idx);
        return -1;
      }
    }
    
    indices[count++] = idx - 1;
    token = strtok(NULL, " ");
  }
  
  return count;
}

void discard_and_draw(struct gamestate* gstate, PlayerID player, uint8_t* indices,
                     int count, int draw_replacements, GameContext* ctx)
{ for(int i = 0; i < count - 1; i++)
  { for(int j = i + 1; j < count; j++)
    { if(indices[i] < indices[j])
      { uint8_t temp = indices[i]; indices[i] = indices[j]; indices[j] = temp; }
    }
  }
  
  for(int i = 0; i < count; i++)
  { uint8_t card_idx = gstate->hand[player].cards[indices[i]];
    HDCLL_removeNodeByValue(&gstate->hand[player], card_idx);
    HDCLL_insertNodeAtBeginning(&gstate->discard[player], card_idx);
  }
  
  if(draw_replacements)
  { for(int i = 0; i < count; i++)
      draw_1_card(gstate, player, ctx);
  }
}

/* ========================================================================
   Mulligan Functions
   ======================================================================== */

static void display_mulligan_prompt(struct gamestate* gstate, PlayerID player)
{ printf("\n" YELLOW "=== Mulligan Phase (Player B) ===" RESET "\n");
  printf("You may discard up to 2 cards and draw replacements.\n");
  printf("Tip: Consider discarding cards with power < %.2f\n\n", AVERAGE_POWER_FOR_MULLIGAN);
  
  printf("Your starting hand:\n");
  for(uint8_t i = 0; i < gstate->hand[player].size; i++)
    display_card_with_index(gstate->hand[player].cards[i], i + 1, 1);
  
  printf("\nCommands:\n");
  printf("  mull <indices>  - Mulligan 1-2 cards (e.g., 'mull 1 3')\n");
  printf("  pass            - Keep current hand\n");
  printf("  help            - Show this help\n\n> ");
}

static int process_mulligan_command(char* input_buffer, struct gamestate* gstate, GameContext* ctx)
{ input_buffer[strcspn(input_buffer, "\n")] = 0;
  PlayerID player = PLAYER_B;
  
  if(strcmp(input_buffer, "pass") == 0)
  { printf(GREEN "âœ“ Keeping current hand\n" RESET);
    return 1;
  }
  else if(strcmp(input_buffer, "help") == 0)
  { display_mulligan_prompt(gstate, player);
    return 0;
  }
  else if(strncmp(input_buffer, "mull ", 5) == 0)
  { uint8_t indices[2];
    int count = parse_card_indices_cli(input_buffer + 5, indices, 2, gstate->hand[player].size);
    
    if(count < 0) return 0;
    if(count == 0)
    { printf(RED "Error: Must specify at least 1 card to mulligan\n" RESET);
      return 0;
    }
    
    printf(GREEN "âœ“ Mulliganing %d card(s)...\n" RESET, count);
    discard_and_draw(gstate, player, indices, count, 1, ctx);
    
    printf("\nNew hand:\n");
    display_player_hand(player, gstate);
    return 1;
  }
  else
  { printf(RED "Unknown command. Type 'help' for commands.\n" RESET);
    return 0;
  }
}

static int handle_interactive_mulligan(struct gamestate* gstate, GameContext* ctx)
{ char input_buffer[MAX_COMMAND_LEN];
  int mulligan_done = 0;
  
  display_mulligan_prompt(gstate, PLAYER_B);
  
  while(!mulligan_done)
  { if(fgets(input_buffer, sizeof(input_buffer), stdin) == NULL)
    { printf(YELLOW "Input error, keeping current hand\n" RESET);
      return 0;
    }
    mulligan_done = process_mulligan_command(input_buffer, gstate, ctx);
  }
  return 0;
}

/* ========================================================================
   Discard-to-7 Functions
   ======================================================================== */

static void display_discard_prompt(struct gamestate* gstate, PlayerID player)
{ int excess = gstate->hand[player].size - 7;
  
  printf("\n" YELLOW "=== Discard Phase ===" RESET "\n");
  printf("You have %d cards. You must discard %d card%s to reach 7.\n",
         gstate->hand[player].size, excess, (excess > 1) ? "s" : "");
  printf("Tip: Consider discarding lowest power cards\n\n");
  
  printf("Your hand:\n");
  for(uint8_t i = 0; i < gstate->hand[player].size; i++)
    display_card_with_index(gstate->hand[player].cards[i], i + 1, 1);
  
  printf("\nCommands:\n");
  printf("  disc <indices>  - Discard cards (e.g., 'disc 2 5')\n");
  printf("  help            - Show this help\n\n> ");
}

static int process_discard_command(char* input_buffer, struct gamestate* gstate,
                                   int cards_to_discard, GameContext* ctx)
{ input_buffer[strcspn(input_buffer, "\n")] = 0;
  PlayerID player = gstate->current_player;
  
  if(strcmp(input_buffer, "help") == 0)
  { display_discard_prompt(gstate, player);
    return 0;
  }
  else if(strncmp(input_buffer, "disc ", 5) == 0)
  { uint8_t indices[15];
    int count = parse_card_indices_cli(input_buffer + 5, indices, cards_to_discard,
                                      gstate->hand[player].size);
    
    if(count < 0) return 0;
    if(count != cards_to_discard)
    { printf(RED "Error: Must discard exactly %d card%s\n" RESET,
             cards_to_discard, (cards_to_discard > 1) ? "s" : "");
      return 0;
    }
    
    printf(GREEN "âœ“ Discarding %d card(s)...\n" RESET, count);
    discard_and_draw(gstate, player, indices, count, 0, ctx);
    
    printf("\nRemaining hand (%d cards):\n", gstate->hand[player].size);
    display_player_hand(player, gstate);
    return 1;
  }
  else
  { printf(RED "Unknown command. Type 'help' for commands.\n" RESET);
    return 0;
  }
}

static int handle_interactive_discard_to_7(struct gamestate* gstate, GameContext* ctx)
{ if(gstate->hand[gstate->current_player].size <= 7)
    return 0;
  
  char input_buffer[MAX_COMMAND_LEN];
  int discard_done = 0;
  int cards_to_discard = gstate->hand[gstate->current_player].size - 7;
  
  display_discard_prompt(gstate, gstate->current_player);
  
  while(!discard_done)
  { if(fgets(input_buffer, sizeof(input_buffer), stdin) == NULL)
    { printf(YELLOW "Input error, auto-discarding lowest power cards\n" RESET);
      discard_to_7_cards(gstate, ctx);
      return 0;
    }
    discard_done = process_discard_command(input_buffer, gstate, cards_to_discard, ctx);
  }
  return 0;
}

/* ========================================================================
   Original Display Functions (unchanged)
   ======================================================================== */

void display_player_prompt(PlayerID player, struct gamestate* gstate, int is_defense)
{ const char* player_color = (player == PLAYER_A) ? COLOR_P1 : COLOR_P2;
  const char* player_name = (player == PLAYER_A) ? "Player A" : "Player B";
  const char* phase_icon = is_defense ? "ðŸ›¡" : "âš”";

  printf("%s%s" RESET " [" COLOR_ENERGY "â¤ %d" RESET " " COLOR_LUNA "â˜¾%d" RESET "] %s âŸ¡ ",
         player_color, player_name, gstate->current_energy[player],
         gstate->current_cash_balance[player], phase_icon);
}

void display_player_hand(PlayerID player, struct gamestate* gstate)
{ printf("\nYour hand:\n");
  for(uint8_t i = 0; i < gstate->hand[player].size; i++)
    display_card_with_index(gstate->hand[player].cards[i], i + 1, 0);
}

void display_attack_state(struct gamestate* gstate)
{ printf("\n" RED "=== Combat! You are being attacked ===" RESET "\n");
  printf("Attacker's champions:\n");
  
  struct LLNode* current = gstate->combat_zone[gstate->current_player].head;
  for(uint8_t i = 0; i < gstate->combat_zone[gstate->current_player].size; i++)
  { const struct card* c = &fullDeck[current->data];
    printf("  - %s (D%d+%d)\n", CHAMPION_SPECIES_NAMES[c->species],
           c->defense_dice, c->attack_base);
    current = current->next;
  }
}

void display_game_status(struct gamestate* gstate)
{ printf("\n" BOLD_WHITE "=== Game Status ===" RESET "\n");
  printf(COLOR_P1 "Player A" RESET ": " COLOR_ENERGY "â¤ %d" RESET
         " " COLOR_LUNA "â˜¾%d" RESET " Hand:%d Deck:%d\n",
         gstate->current_energy[PLAYER_A], gstate->current_cash_balance[PLAYER_A],
         gstate->hand[PLAYER_A].size, gstate->deck[PLAYER_A].top + 1);
  printf(COLOR_P2 "Player B" RESET ": " COLOR_ENERGY "â¤ %d" RESET
         " " COLOR_LUNA "â˜¾%d" RESET " Hand:%d Deck:%d\n",
         gstate->current_energy[PLAYER_B], gstate->current_cash_balance[PLAYER_B],
         gstate->hand[PLAYER_B].size, gstate->deck[PLAYER_B].top + 1);
}

void display_cli_help(int is_defense)
{ printf("\n" BOLD_WHITE "=== Commands ===" RESET "\n");
  if(is_defense)
  { printf("  cham <indices>  - Defend with 1-3 champions (e.g., 'cham 1 2')\n");
    printf("  pass            - Take damage without defending\n");
  }
  else
  { printf("  cham <indices>  - Attack with 1-3 champions (e.g., 'cham 1 3')\n");
    printf("  draw <index>    - Play draw/recall card (e.g., 'draw 2')\n");
    printf("  cash <index>    - Play exchange card (e.g., 'cash 1')\n");
    printf("  pass            - Pass your turn\n");
    printf("  gmst            - Show game status\n");
  }
  printf("  help            - Show this help\n");
  printf("  exit            - Quit game\n\n");
}

/* ========================================================================
   Original Input/Validation Functions (unchanged from previous)
   Keep: parse_champion_indices, validate_and_play_champions,
         handle_draw_command, handle_cash_command, process_champion_command,
         process_attack_command, process_defense_command
   ======================================================================== */

int parse_champion_indices(char* input, uint8_t* indices, int max_count, int hand_size)
{ int count = 0;
  char* token = strtok(input, " ");
  
  while(token != NULL && count < max_count)
  { int idx = atoi(token);
    if(idx < 1 || idx > hand_size)
    { printf(RED "Error: Invalid card number %d (must be 1-%d)\n" RESET, idx, hand_size);
      return -1;
    }
    indices[count++] = idx - 1;
    token = strtok(NULL, " ");
  }
  return count;
}

int validate_and_play_champions(struct gamestate* gstate, PlayerID player,
                                uint8_t* indices, int count, GameContext* ctx)
{ if(count <= 0) return NO_ACTION;

  int total_cost = 0;
  uint8_t* hand_array = HDCLL_toArray(&gstate->hand[player]);

  for(int i = 0; i < count; i++)
  { uint8_t card_idx = hand_array[indices[i]];
    if(fullDeck[card_idx].card_type != CHAMPION_CARD)
    { printf(RED "Error: Card %d is not a champion\n" RESET, indices[i] + 1);
      free(hand_array);
      return NO_ACTION;
    }
    total_cost += fullDeck[card_idx].cost;
  }

  if(total_cost > gstate->current_cash_balance[player])
  { printf(RED "Error: Not enough lunas (need %d, have %d)\n" RESET,
           total_cost, gstate->current_cash_balance[player]);
    free(hand_array);
    return NO_ACTION;
  }

  for(int i = count - 1; i >= 0; i--)
    play_champion(gstate, player, hand_array[indices[i]], ctx);

  free(hand_array);
  printf(GREEN "âœ“ Played %d champion(s)\n" RESET, count);
  return ACTION_TAKEN;
}

int handle_draw_command(struct gamestate* gstate, PlayerID player, char* input, GameContext* ctx)
{ int idx = atoi(input);
  if(idx < 1 || idx > gstate->hand[player].size)
  { printf(RED "Error: Invalid card number (must be 1-%d)\n" RESET, gstate->hand[player].size);
    return NO_ACTION;
  }

  uint8_t* hand_array = HDCLL_toArray(&gstate->hand[player]);
  uint8_t card_idx = hand_array[idx - 1];
  free(hand_array);

  if(fullDeck[card_idx].card_type != DRAW_CARD)
  { printf(RED "Error: Not a draw card\n" RESET);
    return NO_ACTION;
  }

  if(fullDeck[card_idx].cost > gstate->current_cash_balance[player])
  { printf(RED "Error: Not enough lunas\n" RESET);
    return NO_ACTION;
  }

  play_draw_card(gstate, player, card_idx, ctx);
  printf(GREEN "âœ“ Played draw card\n" RESET);
  return ACTION_TAKEN;
}

int handle_cash_command(struct gamestate* gstate, PlayerID player, char* input, GameContext* ctx)
{ int idx = atoi(input);
  if(idx < 1 || idx > gstate->hand[player].size)
  { printf(RED "Error: Invalid card number (must be 1-%d)\n" RESET, gstate->hand[player].size);
    return NO_ACTION;
  }

  uint8_t* hand_array = HDCLL_toArray(&gstate->hand[player]);
  uint8_t card_idx = hand_array[idx - 1];
  free(hand_array);

  if(fullDeck[card_idx].card_type != CASH_CARD)
  { printf(RED "Error: Not an exchange card\n" RESET);
    return NO_ACTION;
  }

  if(!has_champion_in_hand(&gstate->hand[player]))
  { printf(RED "Error: No champions to exchange\n" RESET);
    return NO_ACTION;
  }

  play_cash_card(gstate, player, card_idx, ctx);
  printf(GREEN "âœ“ Played exchange card\n" RESET);
  return ACTION_TAKEN;
}

static int process_champion_command(char* input, struct gamestate* gstate,
                                    PlayerID player, GameContext* ctx)
{ uint8_t indices[3];
  int count = parse_champion_indices(input, indices, 3, gstate->hand[player].size);
  if(count > 0 && validate_and_play_champions(gstate, player, indices, count, ctx))
    return ACTION_TAKEN;
  return NO_ACTION;
}

static int process_attack_command(char* input_buffer, struct gamestate* gstate, GameContext* ctx)
{ input_buffer[strcspn(input_buffer, "\n")] = 0;

  if(strncmp(input_buffer, "cham ", 5) == 0)
    return process_champion_command(input_buffer + 5, gstate, PLAYER_A, ctx);
  else if(strncmp(input_buffer, "draw ", 5) == 0)
    return handle_draw_command(gstate, PLAYER_A, input_buffer + 5, ctx);
  else if(strncmp(input_buffer, "cash ", 5) == 0)
    return handle_cash_command(gstate, PLAYER_A, input_buffer + 5, ctx);
  else if(strcmp(input_buffer, "pass") == 0)
  { printf(YELLOW "Passed turn\n" RESET);
    return ACTION_TAKEN;
  }
  else if(strcmp(input_buffer, "gmst") == 0)
  { display_game_status(gstate);
    return NO_ACTION;
  }
  else if(strcmp(input_buffer, "help") == 0)
  { display_cli_help(0);
    return NO_ACTION;
  }
  else if(strcmp(input_buffer, "exit") == 0)
    return EXIT_SIGNAL;

  printf(RED "Unknown command. Type 'help' for commands.\n" RESET);
  return NO_ACTION;
}

static int process_defense_command(char* input_buffer, struct gamestate* gstate, GameContext* ctx)
{ input_buffer[strcspn(input_buffer, "\n")] = 0;

  if(strcmp(input_buffer, "exit") == 0)
    return EXIT_SIGNAL;
  else if(strcmp(input_buffer, "pass") == 0)
  { printf(YELLOW "Taking damage without defending\n" RESET);
    return NO_ACTION;
  }
  else if(strncmp(input_buffer, "cham ", 5) == 0)
  { uint8_t indices[3];
    int count = parse_champion_indices(input_buffer + 5, indices, 3,
                                       gstate->hand[PLAYER_A].size);
    if(count > 0)
    { if(!validate_and_play_champions(gstate, PLAYER_A, indices, count, ctx))
        printf(YELLOW "Taking damage without defending\n" RESET);
    }
    else if(count == 0)
      printf(YELLOW "No defenders specified, taking damage\n" RESET);
  }
  else if(strcmp(input_buffer, "help") == 0)
    display_cli_help(1);
  else
  { printf(RED "Unknown command. Use 'cham <indices>' or 'pass'\n" RESET);
    printf(YELLOW "Taking damage without defending\n" RESET);
  }

  return NO_ACTION;
}

/* ========================================================================
   Game Phase Handlers (unchanged)
   ======================================================================== */

static int handle_interactive_attack(struct gamestate* gstate, GameContext* ctx)
{ char input_buffer[MAX_COMMAND_LEN];
  int action_taken = NO_ACTION;

  while(!action_taken && !gstate->someone_has_zero_energy)
  { printf("\n=== %s's Turn (Turn %d), Round (%d) ===\n",
           PLAYER_NAMES[PLAYER_A], gstate->turn, (uint16_t)((gstate->turn - 1) * 0.5 + 1));
    printf("\n=== Defender's Status ===\n");
    display_player_prompt(PLAYER_B, gstate, 1);
    printf("\n");
    display_player_prompt(PLAYER_A, gstate, 0);
    display_player_hand(PLAYER_A, gstate);
    printf("\nCommands: cham <indices>, draw <index>, cash <index>, pass, gmst, help, exit\n> ");

    if(fgets(input_buffer, sizeof(input_buffer), stdin) == NULL)
    { printf("Error reading input.\n");
      return EXIT_SIGNAL;
    }

    action_taken = process_attack_command(input_buffer, gstate, ctx);
    if(action_taken == EXIT_SIGNAL) return EXIT_SIGNAL;
  }

  return EXIT_SUCCESS;
}

static int handle_interactive_defense(struct gamestate* gstate, GameContext* ctx)
{ char input_buffer[MAX_COMMAND_LEN];

  printf("\n=== %s's Turn (Turn %d), Round (%d) ===\n",
         PLAYER_NAMES[PLAYER_A], gstate->turn, (uint16_t)((gstate->turn - 1) * 0.5 + 1));
  display_attack_state(gstate);
  
  printf("\n=== Opponent Status ===\n");
  display_player_prompt(PLAYER_B, gstate, 0);
  
  printf("\n");
  display_player_prompt(PLAYER_A, gstate, 1);
  display_player_hand(PLAYER_A, gstate);
  printf("\nDefend: 'cham <indices>' (e.g., 'cham 1 2') or 'pass' to take damage\n> ");

  if(fgets(input_buffer, sizeof(input_buffer), stdin) == NULL)
    return EXIT_SUCCESS;

  int result = process_defense_command(input_buffer, gstate, ctx);
  return (result == EXIT_SIGNAL) ? EXIT_SIGNAL : EXIT_SUCCESS;
}

static int execute_game_turn(struct gamestate* gstate, StrategySet* strategies, GameContext* ctx)
{ begin_of_turn(gstate, ctx);

  if(gstate->current_player == PLAYER_A)
  { int result = handle_interactive_attack(gstate, ctx);
    if(result == EXIT_SIGNAL) return EXIT_SIGNAL;
  }
  else
    attack_phase(gstate, strategies, ctx);

  if(gstate->combat_zone[gstate->current_player].size > 0)
  { if(gstate->current_player == PLAYER_A)
      defense_phase(gstate, strategies, ctx);
    else
    { int result = handle_interactive_defense(gstate, ctx);
      if(result == EXIT_SIGNAL) return EXIT_SIGNAL;
    }
    resolve_combat(gstate, ctx);
  }

  return EXIT_SUCCESS;
}

/* ========================================================================
   Game Initialization and Cleanup (unchanged)
   ======================================================================== */

static struct gamestate* initialize_cli_game(uint16_t initial_cash,
                                             StrategySet** strategies_out, GameContext** ctx_out)
{ GameContext* ctx = create_game_context(M_TWISTER_SEED, NULL);
  if(ctx == NULL) return NULL;

  StrategySet* strategies = create_strategy_set();
  set_player_strategy(strategies, PLAYER_A, random_attack_strategy, random_defense_strategy);
  set_player_strategy(strategies, PLAYER_B, random_attack_strategy, random_defense_strategy);

  struct gamestate* gstate = malloc(sizeof(struct gamestate));
  setup_game(initial_cash, gstate, ctx);

  *strategies_out = strategies;
  *ctx_out = ctx;
  return gstate;
}

static void cleanup_cli_game(struct gamestate* gstate, StrategySet* strategies, GameContext* ctx)
{ DeckStk_emptyOut(&gstate->deck[PLAYER_A]);
  DeckStk_emptyOut(&gstate->deck[PLAYER_B]);
  HDCLL_emptyOut(&gstate->combat_zone[PLAYER_A]);
  HDCLL_emptyOut(&gstate->combat_zone[PLAYER_B]);
  HDCLL_emptyOut(&gstate->hand[PLAYER_A]);
  HDCLL_emptyOut(&gstate->hand[PLAYER_B]);
  HDCLL_emptyOut(&gstate->discard[PLAYER_A]);
  HDCLL_emptyOut(&gstate->discard[PLAYER_B]);

  free(gstate);
  free_strategy_set(strategies);
  destroy_game_context(ctx);
}

/* ========================================================================
   Main CLI Mode Entry Point (UPDATED with Mulligan & Discard)
   ======================================================================== */

int run_mode_stda_cli(config_t* cfg)
{
  #ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);
  #endif

  printf("Running in command line interface mode...\n");

  StrategySet* strategies;
  GameContext* ctx;
  struct gamestate* gstate = initialize_cli_game(INITIAL_CASH_DEFAULT, &strategies, &ctx);
  if(gstate == NULL)
  { fprintf(stderr, "Failed to initialize CLI game\n");
    return EXIT_FAILURE;
  }
  
  printf("\nYou are Player A\n");
  printf("Player B is the RANDOM AI engine\n");
  
  printf("\n=== Game Start ===\n");
  gstate->turn = 0;
  
  // UPDATED: Mulligan phase for Player B
  // Note: Currently Player A is always human, Player B is always AI
  // When implementing player choice, check which player is human
  apply_mulligan(gstate, ctx);  // AI mulligan for Player B
  
  // Main game loop
  while(gstate->turn < MAX_NUMBER_OF_TURNS && !gstate->someone_has_zero_energy)
  { int result = execute_game_turn(gstate, strategies, ctx);
    if(result == EXIT_SIGNAL) break;

    if(gstate->someone_has_zero_energy) break;

    collect_1_luna(gstate);
    
    // UPDATED: Discard-to-7 phase
    if(gstate->current_player == PLAYER_A)  // Human player
      handle_interactive_discard_to_7(gstate, ctx);
    else  // AI player
      discard_to_7_cards(gstate, ctx);
    
    change_current_player(gstate);
  }

  // Determine final game state
  if(!gstate->someone_has_zero_energy)
    gstate->game_state = DRAW;

  // Display final result
  printf("\n" BOLD_WHITE "=== Game Over ===" RESET "\n");
  if(gstate->game_state == PLAYER_A_WINS)
    printf(GREEN "ðŸŽ‰ You Win! ðŸŽ‰\n" RESET);
  else if(gstate->game_state == PLAYER_B_WINS)
    printf(RED "AI Wins!\n" RESET);
  else
    printf(YELLOW "Draw!\n" RESET);
  
  printf("\nFinal Status:\n");
  printf(COLOR_P1 "Player A" RESET ": " COLOR_ENERGY "â¤ %d" RESET
         " " COLOR_LUNA "â˜¾%d" RESET " Hand:%d\n",
         gstate->current_energy[PLAYER_A], gstate->current_cash_balance[PLAYER_A],
         gstate->hand[PLAYER_A].size);
  printf(COLOR_P2 "Player B" RESET ": " COLOR_ENERGY "â¤ %d" RESET
         " " COLOR_LUNA "â˜¾%d" RESET " Hand:%d\n",
         gstate->current_energy[PLAYER_B], gstate->current_cash_balance[PLAYER_B],
         gstate->hand[PLAYER_B].size);
  printf("Game lasted %d turns (%d rounds)\n",
         gstate->turn, (uint16_t)((gstate->turn - 1) * 0.5 + 1));

  cleanup_cli_game(gstate, strategies, ctx);
  return EXIT_SUCCESS;
}