// Mulligan implementation for stda_cli.c

/* ========================================================================
   Mulligan Phase Functions
   ======================================================================== */

// Display mulligan prompt and hand
static void display_mulligan_prompt(struct gamestate* gstate, PlayerID player)
{ printf("\n" YELLOW "=== Mulligan Phase (Player B) ===" RESET "\n");
  printf("You may discard up to 2 cards and draw replacements.\n");
  printf("Tip: Consider discarding cards with power < %.2f\n\n",
         AVERAGE_POWER_FOR_MULLIGAN);
  
  printf("Your starting hand:\n");
  for(uint8_t i = 0; i < gstate->hand[player].size; i++)
  { uint8_t card_idx = gstate->hand[player].cards[i];
    display_card_with_index(card_idx, i + 1, 1);  // Show power
  }
  
  printf("\nCommands:\n");
  printf("  mull <indices>  - Mulligan 1-2 cards (e.g., 'mull 1 3')\n");
  printf("  pass            - Keep current hand\n");
  printf("  help            - Show this help\n");
  printf("\n> ");
}

// Process mulligan command
static int process_mulligan_command(char* input_buffer, 
                                    struct gamestate* gstate,
                                    GameContext* ctx)
{ input_buffer[strcspn(input_buffer, "\n")] = 0;
  PlayerID player = PLAYER_B;  // Only Player B mulligans
  
  if(strcmp(input_buffer, "pass") == 0)
  { printf(GREEN "✓ Keeping current hand\n" RESET);
    return 1;  // Done with mulligan
  }
  else if(strcmp(input_buffer, "help") == 0)
  { display_mulligan_prompt(gstate, player);
    return 0;  // Not done yet
  }
  else if(strncmp(input_buffer, "mull ", 5) == 0)
  { uint8_t indices[2];  // Max 2 cards for mulligan
    int count = parse_card_indices(input_buffer + 5, indices, 2,
                                   gstate->hand[player].size);
    
    if(count < 0)
      return 0;  // Parse error, try again
    
    if(count == 0)
    { printf(RED "Error: Must specify at least 1 card to mulligan\n" RESET);
      return 0;
    }
    
    printf(GREEN "✓ Mulliganing %d card(s)...\n" RESET, count);
    discard_and_draw(gstate, player, indices, count, 1, ctx);
    
    printf("\nNew hand:\n");
    display_player_hand(player, gstate);
    
    return 1;  // Done with mulligan
  }
  else
  { printf(RED "Unknown command. Type 'help' for commands.\n" RESET);
    return 0;  // Not done yet
  }
}

// Main mulligan handler for interactive player
static int handle_interactive_mulligan(struct gamestate* gstate, 
                                       GameContext* ctx)
{ char input_buffer[MAX_COMMAND_LEN];
  int mulligan_done = 0;
  
  display_mulligan_prompt(gstate, PLAYER_B);
  
  while(!mulligan_done)
  { if(fgets(input_buffer, sizeof(input_buffer), stdin) == NULL)
    { printf(YELLOW "Input error, keeping current hand\n" RESET);
      return 0;
    }
    
    mulligan_done = process_mulligan_command(input_buffer, gstate, ctx);
  }
  
  return 0;
}
